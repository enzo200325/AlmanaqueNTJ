\documentclass[11pt, a4paper, twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
\addtolength{\parskip}{.5\baselineskip}

%aqui comeca o que eu fiz de verdade, o resto veio e eu to com medo de tirar
\usepackage{xcolor}
\usepackage{listings} %biblioteca pro codigo
\usepackage{color}    %deixa o codigo colorido bonitinho
\usepackage[landscape, left=1.5cm, right=1.5cm, top=1cm, bottom=2cm]{geometry} %pra deixar a margem do jeito que o brasil gosta

\definecolor{gray}{rgb}{0.4, 0.4, 0.4} %cor pros comentarios
\renewcommand{\footnotesize}{\small} %isso eh pra mudar o tamanho da fonte do codigo
\setlength{\columnseprule}{0.2pt} %barra separando as duas colunas
\setlength{\columnsep}{20pt} %distancia do texto ate a barra

\lstset{ %opcoes pro codigo
breaklines=true,
keywordstyle=\color{purple}\bfseries,
commentstyle=\color{gray},
breakatwhitespace=true,
language=C++,
%frame=single, % nao sei se gosto disso ou nao
numbers=none,
rulecolor=\color{black},
showstringspaces=false
stringstyle=\color{purple},
tabsize=4,
basicstyle=\ttfamily\footnotesize, % fonte
}
\lstset{literate=
%   *{0}{{{\color{red!20!violet}0}}}1
%    {1}{{{\color{red!20!violet}1}}}1
%    {2}{{{\color{red!20!violet}2}}}1
%    {3}{{{\color{red!20!violet}3}}}1
%    {4}{{{\color{red!20!violet}4}}}1
%    {5}{{{\color{red!20!violet}5}}}1
%    {6}{{{\color{red!20!violet}6}}}1
%    {7}{{{\color{red!20!violet}7}}}1
%    {8}{{{\color{red!20!violet}8}}}1
%    {9}{{{\color{red!20!violet}9}}}1
%	 {l}{$\text{l}$}1
	{~}{$\sim$}{1} % ~ bonitinho
}

\title{NTJ \\ UDESC}
\author{Eric Grochowicz, Enzo de Almeida Rodrigues e João Marcos de Oliveira}


\begin{document}
\twocolumn
\date{\today}
\maketitle


\renewcommand{\contentsname}{Índice} %troca o nome do indice para indice
\tableofcontents


%%%%%%%%%%%%%%%%%%%%
%
% DP
%
%%%%%%%%%%%%%%%%%%%%

\section{DP}



%%%%%%%%%%%%%%%%%%%%
%
% Problemas
%
%%%%%%%%%%%%%%%%%%%%

\section{Problemas}



%%%%%%%%%%%%%%%%%%%%
%
% Matematica
%
%%%%%%%%%%%%%%%%%%%%

\section{Matematica}



%%%%%%%%%%%%%%%%%%%%
%
% Primitivas
%
%%%%%%%%%%%%%%%%%%%%

\section{Primitivas}



%%%%%%%%%%%%%%%%%%%%
%
% Estruturas
%
%%%%%%%%%%%%%%%%%%%%

\section{Estruturas}

\subsection{Fenwick Tree}
\begin{lstlisting}
// Processas queries de operacao com inverso
// em O(log(n)) e faz updates em O(log(n))

 typedef long long ll;
 
 struct fenwick {
     vector<ll> bit;
     fenwick (int n) { bit.assign(n+1, 0); }
     ll query(int i){
         ll res = 0;
         for(; i; i -= (i & -i))
             res += bit[i];
         return res;
     }
     ll query(int l, int r){
         return query(r) - query(l-1);
     }
     void update(int i, ll d){
         for(; i && i < (int)bit.size(); i += (i & -i))
             bit[i] += d;
     }
 };
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Grafos
%
%%%%%%%%%%%%%%%%%%%%

\section{Grafos}

\subsection{Bridges e ebcc}
\begin{lstlisting}
// dfaffds
// fsf
// dsa
// fadsfsad
// f

 const int maxn = 4e5;
 int n, m;
 bool vis[maxn];
 int dp[maxn], dep[maxn];
 vector<int> adj[maxn];
 vector<ii> bridges;
 
 void dfs_dp(int u, int p = -1, int d = 0){
     dp[u] = 0, dep[u] = d, vis[u] = 1;
     for(auto v : adj[u]) if(v != p) {
         if(vis[v]){
             if(dep[v] < dep[u]) dp[v]--, dp[u]++;
         } else {
             dfs_dp(v, u, d+1);
             dp[u] += dp[v];
         }
     }
     if(dp[u] == 0 && p != -1){ // edge {u, p} eh uma ponte
         bridges.emplace_back(u, p);
     }
 }
 
 void find_bridges(){
     memset(vis, 0, n+1);
     for(int i = 1; i <= n; i++){
         if(!vis[i]) dfs_dp(i);
     }
 }
 
 // EDGE BICONNECTED COMPONENTS (requer todo codigo acima)
 int ebcc[maxn], ncc = 1;
 vector<int> adjbcc[maxn];
 
 void dfs_ebcc(int u, int p = -1, int cc = 1){
     vis[u] = 1;
     if(dp[u] == 0 && p != -1){
         cc = ++ncc;
     }
     ebcc[u] = cc;
     for(auto v : adj[u]) if(!vis[v]) {
         dfs_ebcc(v, u, cc);
     }
 }
 
 void build_ebcc_graph(){
     find_bridges();
     memset(vis, 0, n+1);
     for(int i = 1; i <= n; i++){
         if(!vis[i]) dfs_ebcc(i);
     }
     // Opcao 1 - constroi o grafo condensado passando por todas as edges
     for(int u = 1; u <= n; u++){
         for(auto v : adj[u]){
             if(ebcc[u] != ebcc[v]){
                 adjbcc[ebcc[u]].emplace_back(ebcc[v]);
             } else {
                 // faz algo
             }
         }
     }
     // Opcao 2 - constroi o grafo condensado passando so pelas pontes
     for(auto [u,v] : bridges){
         adjbcc[ebcc[u]].emplace_back(ebcc[v]);
         adjbcc[ebcc[v]].emplace_back(ebcc[u]);
     }
 }
\end{lstlisting}

\subsection{Fenwick Tree}
\begin{lstlisting}
// Processas queries de operacao com inverso
// em O(log(n)) e faz updates em O(log(n))

 typedef long long ll;
 
 struct fenwick {
     vector<ll> bit;
     fenwick (int n) { bit.assign(n+1, 0); }
     ll query(int i){
         ll res = 0;
         for(; i; i -= (i & -i))
             res += bit[i];
         return res;
     }
     ll query(int l, int r){
         return query(r) - query(l-1);
     }
     void update(int i, ll d){
         for(; i && i < (int)bit.size(); i += (i & -i))
             bit[i] += d;
     }
 };
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Strings
%
%%%%%%%%%%%%%%%%%%%%

\section{Strings}

\pagebreak


%%%%%%%%%%%%%%%%%%%%
%
% Extra
%
%%%%%%%%%%%%%%%%%%%%

\section{Extra}

\subsection{bridges.cpp}
\begin{lstlisting}
// Bridges e ebcc
//
// dfaffds
// fsf
// dsa
// fadsfsad
// f

const int maxn = 4e5;
int n, m;
bool vis[maxn];
int dp[maxn], dep[maxn];
vector<int> adj[maxn];
vector<ii> bridges;

void dfs_dp(int u, int p = -1, int d = 0){
    dp[u] = 0, dep[u] = d, vis[u] = 1;
    for(auto v : adj[u]) if(v != p) {
        if(vis[v]){
            if(dep[v] < dep[u]) dp[v]--, dp[u]++;
        } else {
            dfs_dp(v, u, d+1);
            dp[u] += dp[v];
        }
    }
    if(dp[u] == 0 && p != -1){ // edge {u, p} eh uma ponte
        bridges.emplace_back(u, p);
    }
}

void find_bridges(){
    memset(vis, 0, n+1);
    for(int i = 1; i <= n; i++){
        if(!vis[i]) dfs_dp(i);
    }
}

// EDGE BICONNECTED COMPONENTS (requer todo codigo acima)
int ebcc[maxn], ncc = 1;
vector<int> adjbcc[maxn];

void dfs_ebcc(int u, int p = -1, int cc = 1){
    vis[u] = 1;
    if(dp[u] == 0 && p != -1){
        cc = ++ncc;
    }
    ebcc[u] = cc;
    for(auto v : adj[u]) if(!vis[v]) {
        dfs_ebcc(v, u, cc);
    }
}

void build_ebcc_graph(){
    find_bridges();
    memset(vis, 0, n+1);
    for(int i = 1; i <= n; i++){
        if(!vis[i]) dfs_ebcc(i);
    }
    // Opcao 1 - constroi o grafo condensado passando por todas as edges
    for(int u = 1; u <= n; u++){
        for(auto v : adj[u]){
            if(ebcc[u] != ebcc[v]){
                adjbcc[ebcc[u]].emplace_back(ebcc[v]);
            } else {
                // faz algo
            }
        }
    }
    // Opcao 2 - constroi o grafo condensado passando so pelas pontes
    for(auto [u,v] : bridges){
        adjbcc[ebcc[u]].emplace_back(ebcc[v]);
        adjbcc[ebcc[v]].emplace_back(ebcc[u]);
    }
}
\end{lstlisting}

\end{document}
