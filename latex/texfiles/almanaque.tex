\documentclass[11pt, a4paper, twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
\addtolength{\parskip}{.5\baselineskip}

%aqui comeca o que eu fiz de verdade, o resto veio e eu to com medo de tirar
\usepackage{xcolor}
\usepackage{listings} %biblioteca pro codigo
\usepackage{color}    %deixa o codigo colorido bonitinho
\usepackage[landscape, left=1.5cm, right=1.5cm, top=1cm, bottom=2cm]{geometry} %pra deixar a margem do jeito que o brasil gosta

\definecolor{gray}{rgb}{0.4, 0.4, 0.4} %cor pros comentarios
\renewcommand{\footnotesize}{\small} %isso eh pra mudar o tamanho da fonte do codigo
\setlength{\columnseprule}{0.2pt} %barra separando as duas colunas
\setlength{\columnsep}{20pt} %distancia do texto ate a barra

\lstset{ %opcoes pro codigo
breaklines=true,
keywordstyle=\color{purple}\bfseries,
commentstyle=\color{gray},
breakatwhitespace=true,
language=C++,
%frame=single, % nao sei se gosto disso ou nao
numbers=none,
rulecolor=\color{black},
showstringspaces=false
stringstyle=\color{purple},
tabsize=4,
basicstyle=\ttfamily\footnotesize, % fonte
}
\lstset{literate=
%   *{0}{{{\color{red!20!violet}0}}}1
%    {1}{{{\color{red!20!violet}1}}}1
%    {2}{{{\color{red!20!violet}2}}}1
%    {3}{{{\color{red!20!violet}3}}}1
%    {4}{{{\color{red!20!violet}4}}}1
%    {5}{{{\color{red!20!violet}5}}}1
%    {6}{{{\color{red!20!violet}6}}}1
%    {7}{{{\color{red!20!violet}7}}}1
%    {8}{{{\color{red!20!violet}8}}}1
%    {9}{{{\color{red!20!violet}9}}}1
%	 {l}{$\text{l}$}1
	{~}{$\sim$}{1} % ~ bonitinho
}

\title{NTJ \\ UDESC}
\author{Eric Grochowicz, Enzo de Almeida Rodrigues e João Marcos de Oliveira}


\begin{document}
\twocolumn
\date{\today}
\maketitle


\renewcommand{\contentsname}{Índice} %troca o nome do indice para indice
\tableofcontents
\clearpage


%%%%%%%%%%%%%%%%%%%%
%
% Problemas
%
%%%%%%%%%%%%%%%%%%%%

\section{Problemas}

\subsection{Kth digito na string infinita de digitos}
\begin{lstlisting}
// Retorna qual o numero e qual o algarismo do Kth digito 
// na string infinita dos numeros naturais (12345678910111213...)
// Complexidade: O(log_10(k))

 pair<ll,ll> kthdig(ll k){
     ll qtd = 1, num_alg = 1, base = 1;
     while(1){
         ll add = (9 * base) * num_alg;
         if(qtd + add < k){
             qtd += add;
         } else break;
         base *= 10, num_alg++;
     }
     ll algarismo = (k - qtd) % num_alg;
     ll numero = (k - qtd) / num_alg + base;
     return {numero, algarismo};
 }
\end{lstlisting}

\clearpage


%%%%%%%%%%%%%%%%%%%%
%
% Estruturas
%
%%%%%%%%%%%%%%%%%%%%

\section{Estruturas}

\subsection{Fenwick Tree}
\begin{lstlisting}
// Processas queries de operacao com inverso
// Build: O(n)
// Query: O(log(n))
// Update: O(log(n))

 typedef long long ll;
 
 struct fenwick {
     vector<ll> bit;
     fenwick(int n) { bit.assign(n+1, 0); }
     fenwick(vector<ll>& v) {
         int n = v.size();
         bit.assign(n+1, 0);
         for(int i = 1; i <= n; i++) bit[i] = v[i-1];
         for(int i = 1; i <= n; i++) {
             int j = i + (i & -i);
             if(j <= n) bit[j] += bit[i];
         }
     }
     ll query(int i){
         ll res = 0;
         for(; i; i -= (i & -i))
             res += bit[i];
         return res;
     }
     ll query(int l, int r){
         return query(r) - query(l-1);
     }
     void update(int i, ll d){
         for(; i && i < (int)bit.size(); i += (i & -i))
             bit[i] += d;
     }
 };
\end{lstlisting}

\clearpage


%%%%%%%%%%%%%%%%%%%%
%
% Grafos
%
%%%%%%%%%%%%%%%%%%%%

\section{Grafos}

\subsection{Bridges e Edge Biconnected Components}
\begin{lstlisting}
// Acha todas as pontes em O(n)
// Tambem constroi a arvore condensada, mantendo
// so as pontes como arestas e o resto comprimindo
// em nodos

 const int maxn = 4e5;
 int n, m;
 bool vis[maxn];
 int dp[maxn], dep[maxn];
 vector<int> adj[maxn];
 vector<ii> bridges;
 
 void dfs_dp(int u, int p = -1, int d = 0){
     dp[u] = 0, dep[u] = d, vis[u] = 1;
     for(auto v : adj[u]) if(v != p) {
         if(vis[v]){
             if(dep[v] < dep[u]) dp[v]--, dp[u]++;
         } else {
             dfs_dp(v, u, d+1);
             dp[u] += dp[v];
         }
     }
     if(dp[u] == 0 && p != -1){ // edge {u, p} eh uma ponte
         bridges.emplace_back(u, p);
     }
 }
 
 void find_bridges(){
     memset(vis, 0, n+1);
     for(int i = 1; i <= n; i++){
         if(!vis[i]) dfs_dp(i);
     }
 }
 
 // EDGE BICONNECTED COMPONENTS (requer todo codigo acima)
 int ebcc[maxn], ncc = 1;
 vector<int> adjbcc[maxn];
 
 void dfs_ebcc(int u, int p = -1, int cc = 1){
     vis[u] = 1;
     if(dp[u] == 0 && p != -1){
         cc = ++ncc;
     }
     ebcc[u] = cc;
     for(auto v : adj[u]) if(!vis[v]) {
         dfs_ebcc(v, u, cc);
     }
 }
 
 void build_ebcc_graph(){
     find_bridges();
     memset(vis, 0, n+1);
     for(int i = 1; i <= n; i++){
         if(!vis[i]) dfs_ebcc(i);
     }
     // Opcao 1 - constroi o grafo condensado passando por todas as edges
     for(int u = 1; u <= n; u++){
         for(auto v : adj[u]){
             if(ebcc[u] != ebcc[v]){
                 adjbcc[ebcc[u]].emplace_back(ebcc[v]);
             } else {
                 // faz algo
             }
         }
     }
     // Opcao 2 - constroi o grafo condensado passando so pelas pontes
     for(auto [u,v] : bridges){
         adjbcc[ebcc[u]].emplace_back(ebcc[v]);
         adjbcc[ebcc[v]].emplace_back(ebcc[u]);
     }
 }
\end{lstlisting}

\pagebreak


%%%%%%%%%%%%%%%%%%%%
%
% Extra
%
%%%%%%%%%%%%%%%%%%%%

\section{Extra}

\subsection{Config do Vim}
\begin{lstlisting}
// .vimrc

 set number
 set nohls
 set ai
 
 set belloff=all
 
 syntax on
 filetype plugin indent on
 
 set ts=4
 set sw=4
 set expandtab
 set noshiftround
 
 set showmode
 set showcmd
 
 " bracket remap
 inoremap {} {}<Left><Return><Up><End><Return> 
 
 " bracket translator (trocar pra C cedilha)
 nnoremap c :g/{/normal kJx<return>
 nnoremap C :g/{/normal $xo{<return>
\end{lstlisting}

\subsection{Gerador aleatorio de inteiros em [l, r]}
\begin{lstlisting}
 mt19937 rng(chrono::steady_clock::now() .time_since_epoch().count());
 
 ll uniform(ll l, ll r){
 	uniform_int_distribution<int> uid(l, r);
 	return uid(rng);
 }
\end{lstlisting}

\subsection{Rand C++}
\begin{lstlisting}
 mt19937 rng(chrono::steady_clock::now() .time_since_epoch().count());
\end{lstlisting}

\subsection{Script de stress test}
\begin{lstlisting}
 set -e
 g++ code.cpp -o code
 g++ brute.cpp -o brute
 g++ gen.cpp -o gen
 
 for((i = 1; ; ++i)); do
     ./gen > input_file
     ./code < input_file > myAnswer
     ./brute < input_file > correctAnswer
     diff myAnswer correctAnswer > /dev/null || break
     echo "Passed test: "  $i
 done
 
 echo "WA on the following test:"
 cat input_file
 echo "Your answer is:"
 cat myAnswer
 echo "Correct answer is:"
 cat correctAnswer
\end{lstlisting}

\subsection{Template C++}
\begin{lstlisting}
 #include <bits/stdc++.h>
 
 using namespace std;
 
 void solve(){
 
 }
 
 signed main(){
 	ios_base::sync_with_stdio(0); cin.tie(0);
 	solve();
 }
\end{lstlisting}

\subsection{Template de debug simples}
\begin{lstlisting}
 void _print() { }
 template<typename T, typename... U> void _print(T a, U... b) {
     if(sizeof... (b)){
         cerr << a << ", ";
         _print(b...);
     } else cerr << a;
 }
 #define debug(x...) cerr << "[" << #x << "] = [", _print(x), cerr << "]" << endl
 
 // #define debug(...)
\end{lstlisting}

\end{document}
