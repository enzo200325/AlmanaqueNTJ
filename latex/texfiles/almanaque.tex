\documentclass[11pt, a4paper, twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
\addtolength{\parskip}{.5\baselineskip}

%aqui comeca o que eu fiz de verdade, o resto veio e eu to com medo de tirar
\usepackage{xcolor}
\usepackage{listings} %biblioteca pro codigo
\usepackage{color}    %deixa o codigo colorido bonitinho
\usepackage[landscape, left=1.5cm, right=1.5cm, top=1cm, bottom=2cm]{geometry} %pra deixar a margem do jeito que o brasil gosta

\definecolor{gray}{rgb}{0.4, 0.4, 0.4} %cor pros comentarios
\renewcommand{\footnotesize}{\small} %isso eh pra mudar o tamanho da fonte do codigo
\setlength{\columnseprule}{0.2pt} %barra separando as duas colunas
\setlength{\columnsep}{20pt} %distancia do texto ate a barra

\lstset{ %opcoes pro codigo
breaklines=true,
keywordstyle=\color{purple}\bfseries,
commentstyle=\color{gray},
breakatwhitespace=true,
language=C++,
%frame=single, % nao sei se gosto disso ou nao
numbers=none,
rulecolor=\color{black},
showstringspaces=false
stringstyle=\color{purple},
tabsize=4,
basicstyle=\ttfamily\footnotesize, % fonte
}
\lstset{literate=
%   *{0}{{{\color{red!20!violet}0}}}1
%    {1}{{{\color{red!20!violet}1}}}1
%    {2}{{{\color{red!20!violet}2}}}1
%    {3}{{{\color{red!20!violet}3}}}1
%    {4}{{{\color{red!20!violet}4}}}1
%    {5}{{{\color{red!20!violet}5}}}1
%    {6}{{{\color{red!20!violet}6}}}1
%    {7}{{{\color{red!20!violet}7}}}1
%    {8}{{{\color{red!20!violet}8}}}1
%    {9}{{{\color{red!20!violet}9}}}1
%	 {l}{$\text{l}$}1
	{~}{$\sim$}{1} % ~ bonitinho
}

\title{NTJ \\ UDESC}
\author{Eric Grochowicz, Enzo de Almeida Rodrigues e João Marcos de Oliveira}


\begin{document}
\twocolumn
\date{\today}
\maketitle


\renewcommand{\contentsname}{Índice} %troca o nome do indice para indice
\tableofcontents


%%%%%%%%%%%%%%%%%%%%
%
% Estruturas
%
%%%%%%%%%%%%%%%%%%%%

\section{Estruturas}

\subsection{Fenwick Tree}
\begin{lstlisting}
// Processas queries de operacao com inverso
// Build: O(n)
// Query: O(log(n))
// Update: O(log(n))

 typedef long long ll;
 
 struct fenwick {
     vector<ll> bit;
     fenwick(int n) { bit.assign(n+1, 0); }
     fenwick(vector<ll>& v) {
         int n = v.size();
         bit.assign(n+1, 0);
         for(int i = 1; i <= n; i++) bit[i] = v[i-1];
         for(int i = 1, j = 2; i <= n; i++, j = i + (i & -i)) if(j <= n) {
             bit[j] += bit[i];
         }
     }
     ll query(int i){
         ll res = 0;
         for(; i; i -= (i & -i))
             res += bit[i];
         return res;
     }
     ll query(int l, int r){
         return query(r) - query(l-1);
     }
     void update(int i, ll d){
         for(; i && i < (int)bit.size(); i += (i & -i))
             bit[i] += d;
     }
 };
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Grafos
%
%%%%%%%%%%%%%%%%%%%%

\section{Grafos}

\subsection{Bridges e Edge Biconnected Components}
\begin{lstlisting}
// Acha todas as pontes em O(n)
// Tambem constroi a arvore condensada, mantendo
// so as pontes como arestas e o resto comprimindo
// em nodos

 const int maxn = 4e5;
 int n, m;
 bool vis[maxn];
 int dp[maxn], dep[maxn];
 vector<int> adj[maxn];
 vector<ii> bridges;
 
 void dfs_dp(int u, int p = -1, int d = 0){
     dp[u] = 0, dep[u] = d, vis[u] = 1;
     for(auto v : adj[u]) if(v != p) {
         if(vis[v]){
             if(dep[v] < dep[u]) dp[v]--, dp[u]++;
         } else {
             dfs_dp(v, u, d+1);
             dp[u] += dp[v];
         }
     }
     if(dp[u] == 0 && p != -1){ // edge {u, p} eh uma ponte
         bridges.emplace_back(u, p);
     }
 }
 
 void find_bridges(){
     memset(vis, 0, n+1);
     for(int i = 1; i <= n; i++){
         if(!vis[i]) dfs_dp(i);
     }
 }
 
 // EDGE BICONNECTED COMPONENTS (requer todo codigo acima)
 int ebcc[maxn], ncc = 1;
 vector<int> adjbcc[maxn];
 
 void dfs_ebcc(int u, int p = -1, int cc = 1){
     vis[u] = 1;
     if(dp[u] == 0 && p != -1){
         cc = ++ncc;
     }
     ebcc[u] = cc;
     for(auto v : adj[u]) if(!vis[v]) {
         dfs_ebcc(v, u, cc);
     }
 }
 
 void build_ebcc_graph(){
     find_bridges();
     memset(vis, 0, n+1);
     for(int i = 1; i <= n; i++){
         if(!vis[i]) dfs_ebcc(i);
     }
     // Opcao 1 - constroi o grafo condensado passando por todas as edges
     for(int u = 1; u <= n; u++){
         for(auto v : adj[u]){
             if(ebcc[u] != ebcc[v]){
                 adjbcc[ebcc[u]].emplace_back(ebcc[v]);
             } else {
                 // faz algo
             }
         }
     }
     // Opcao 2 - constroi o grafo condensado passando so pelas pontes
     for(auto [u,v] : bridges){
         adjbcc[ebcc[u]].emplace_back(ebcc[v]);
         adjbcc[ebcc[v]].emplace_back(ebcc[u]);
     }
 }
\end{lstlisting}

\pagebreak


%%%%%%%%%%%%%%%%%%%%
%
% Extra
%
%%%%%%%%%%%%%%%%%%%%

\section{Extra}

\subsection{vimrc}
\begin{lstlisting}
// Config do Vim

set number
set nohls
set ai

set belloff=all

syntax on
filetype plugin indent on

set ts=4
set sw=4
set expandtab
set noshiftround

set showmode
set showcmd

" bracket remap
inoremap {} {}<Left><Return><Up><End><Return> 

" bracket translator (trocar pra C cedilha)
nnoremap c :g/{/normal kJx<return>
nnoremap C :g/{/normal $xo{<return>
\end{lstlisting}

\subsection{template.cpp}
\begin{lstlisting}
// Templace C++

#include <bits/stdc++.h>

using namespace std;

void solve(){

}

int main(){
	ios_base::sync_with_stdio(0); cin.tie(0);
	solve();
}
\end{lstlisting}

\end{document}
